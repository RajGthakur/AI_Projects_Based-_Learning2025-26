Code:

 8-Puzzle with Best-First Search + GUI (SWI-Prolog + XPCE)
• State : [1,2,3,4,5,6,7,8,0] (0 = blank)
• Heuristics: misplaced tiles / Manhattan distance
• GUI : Shuffle, Solve, Step, Reset, Stop, clickable tiles
• Tracks : Player move counter + AI optimal moves (for comparison)

:- use_module(library(pce)).
:- use_module(library(lists)). % nth0/3, length/2, reverse/2, sum_list/2
:- use_module(library(random)). % random_member/2
:- use_module(library(pairs)). % map_list_to_pairs/3, pairs_values/2
:- dynamic current_state/1.
:- dynamic solution_queue/1.
:- dynamic last_shuffled/1.
:- dynamic anim_timer/1.
:- dynamic heuristic_mode/1.
:- dynamic move_count/1.
:- dynamic ai_best_moves/1.

% CONFIG

board_px(300).
tile_gap(6).
anim_interval(0.5).
default_start([2,8,3,1,6,4,7,0,5]).
goal([1,2,3,4,5,6,7,8,0]).
heuristic_mode(misplaced).

% GUI ENTRY
start_gui :-
retractall(current_state(_)),
retractall(solution_queue(_)),
retractall(anim_timer(_)),
retractall(heuristic_mode(_)),
retractall(move_count(_)),
retractall(ai_best_moves(_)),
asserta(move_count(0)),
asserta(heuristic_mode(misplaced)),
retractall(last_shuffled(_)),
default_start(S0),
asserta(current_state(S0)),
asserta(last_shuffled(S0)),
board_px(Size),
new(W, dialog('8-Puzzle — Best First Search')),
send(W, append, new(P, picture(board, size(Size, Size)))),
send(W, append, new(Info, text_item(status, 'Ready'))),
send(W, append, new(HM, menu(heuristic, cycle))),
send_list(HM, append, [misplaced, manhattan]),
send(HM, selection, misplaced),
send(HM, message, message(@prolog, set_heuristic, HM?selection, Info)),
send(W, append, button(shuffle, message(@prolog, gui_shuffle, P, Info))),
send(W, append, button(solve, message(@prolog, gui_solve, P, Info))),
send(W, append, button(step, message(@prolog, gui_step, P, Info))),
send(W, append, button(reset, message(@prolog, gui_reset, P, Info))),
send(W, append, button(stop, message(@prolog, gui_stop_anim, Info))),
send(W, open),
draw_board(P, Info).
set_heuristic(H, Info) :-
retractall(heuristic_mode(_)),
asserta(heuristic_mode(H)),
send(Info, selection, string('Heuristic set to %s', H)).

% DRAWING

draw_board(Pic, Info) :-
current_state(S),
send(Pic, clear),
board_px(Size), tile_gap(G),
TileSide is (Size - 4*G) // 3,
forall( nth0(I, S, V),
( Row is I // 3, Col is I mod 3,
X is G + Col*(TileSide+G), Y is G + Row*(TileSide+G),
send(Pic, display, new(B, box(TileSide, TileSide)), point(X, Y)),
( V =:= 0 ->
send(B, fill_pattern, colour(white)),
send(B, pen, 1)
; send(B, fill_pattern, colour(grey90)),
send(B, pen, 2),
send(Pic, display, new(T, text(V, center))),
TX is X + TileSide//2 - 6, TY is Y + TileSide//2 - 8,
send(T, font, font(helvetica, bold, 16)),
send(T, position, point(TX, TY)),
send(B, recogniser, click_gesture(left, '', single,
message(@prolog, tile_clicked, V, Pic, Info)))
)
)),
update_status(Info, S).

% STATUS UPDATES

update_status(Info, S) :-
move_count(M),
( ai_best_moves(K) -> AIText = K ; AIText = '—' ),
( goal(S) ->
send(Info, selection, string('Solved! Your Moves: %d | AI: %s', M, AIText))
; send(Info, selection, string('Moves: %d | AI: %s', M, AIText))
).

% TILE CLICK HANDLER

tile_clicked(Value, Pic, Info) :-
current_state(S),
nth0(PosVal, S, Value),
nth0(PosZero, S, 0),
neighbor(PosVal, PosZero),
swap_pos(S, PosVal, PosZero, NewS),
retractall(current_state(_)), asserta(current_state(NewS)),
inc_moves,
draw_board(Pic, Info)

% GUI ACTIONS

gui_shuffle(P, Info) :-
gui_stop_anim(Info),
current_state(S0),
random_walk(30, S0, S),
retractall(current_state(_)), asserta(current_state(S)),
retractall(last_shuffled(_)), asserta(last_shuffled(S)),
retractall(solution_queue(_)),
reset_moves,
retractall(ai_best_moves(_)),
draw_board(P, Info).
gui_reset(P, Info) :-
gui_stop_anim(Info),
( last_shuffled(S) -> true ; default_start(S) ),
retractall(current_state(_)), asserta(current_state(S)),
retractall(solution_queue(_)),
reset_moves,
retractall(ai_best_moves(_)),
draw_board(P, Info).
gui_solve(P, Info) :-
gui_stop_anim(Info),
current_state(S),
( solve_best_first(S, PathStates) ->
tail(PathStates, Tail), % states after current
length(Tail, NAI), % AI optimal moves
retractall(ai_best_moves(_)), asserta(ai_best_moves(NAI)),
retractall(solution_queue(_)), asserta(solution_queue(Tail)),
send(Info, selection, string('Solution found. AI needs %d moves. Click Step or wait…',
NAI)),
anim_interval(T),
new(Timer, timer(T, message(@prolog, gui_step, P, Info))),
asserta(anim_timer(Timer)),
send(Timer, start)
; send(Info, selection, 'No solution (unsolvable configuration)')
).
gui_step(P, Info) :-
( retract(solution_queue([Next|Rest])) ->
asserta(solution_queue(Rest)),
retractall(current_state(_)), asserta(current_state(Next)),
inc_moves,
draw_board(P, Info),
( Rest == [] ->
gui_stop_anim(Info),
send(Info, selection, 'Goal reached')
; true )
; send(Info, selection, 'Nothing to step')
).
gui_stop_anim(Info) :-
( retract(anim_timer(T)) ->
send(T, stop), send(Info, selection, 'Stopped')
; true).

% BEST-FIRST SEARCH (Greedy)

solve_best_first(Start, PathStates) :-
heuristic(Start, H0),
bestfs([[node(Start, none, H0)]], [], GoalNode),
build_path(GoalNode, [], Rev),
reverse(Rev, PathStates).
bestfs([[node(S, Parent, _H)|_]|_], _, node(S, Parent, 0)) :-
goal(S), !.
bestfs([[node(S, Parent, _H)|RestOpen]|OpenTail], Visited, Goal) :-
findall(node(Next, node(S, Parent, 0), Hn),
( move(S, Next), \+ memberchk(Next, Visited), heuristic(Next, Hn) ),
Children),
append(RestOpen, Children, NewOpen1),
sort_open(NewOpen1, NewOpen),
bestfs([NewOpen|OpenTail], [S|Visited], Goal).
bestfs([[]|OpenTail], Visited, Goal) :-
bestfs(OpenTail, Visited, Goal).
sort_open(List, Sorted) :-
map_list_to_pairs(node_h, List, Pairs),
keysort(Pairs, SortedPairs),
pairs_values(SortedPairs, Sorted).
node_h(node(_,_,H), H).
build_path(node(S, none, _), Acc, [S|Acc]) :- !.
build_path(node(S, Parent, _), Acc, Path) :-
build_path(Parent, [S|Acc], Path).

% HEURISTICS

heuristic(S, H) :- heuristic_mode(misplaced), !, goal(G), misplaced_count(S, G, H).
heuristic(S, H) :- heuristic_mode(manhattan), !, manhattan_sum(S, H).
misplaced_count([], [], 0).
misplaced_count([0|T1], [_|T2], H) :- misplaced_count(T1, T2, H).
misplaced_count([X|T1], [X|T2], H) :- X \= 0, misplaced_count(T1, T2, H).
misplaced_count([X|T1], [Y|T2], H) :- X \= 0, X \= Y, misplaced_count(T1, T2, H1), H is H1
+ 1.
manhattan_sum(State, Sum) :-
goal(G),
findall(D,
( nth0(I, State, V), V =\= 0,
nth0(GI, G, V),
rowcol(I, R1, C1), rowcol(GI, R2, C2),
D is abs(R1-R2) + abs(C1-C2)
), Ds),
sum_list(Ds, Sum).
rowcol(Index, R, C) :- R is Index // 3, C is Index mod 3.

% MOVES

move(S, S2) :-
nth0(ZeroPos, S, 0),
neighbor(ZeroPos, P2),
swap_pos(S, ZeroPos, P2, S2).
neighbor(P, Q) :- member((P,Q),
[(0,1),(0,3),
(1,0),(1,2),(1,4),
(2,1),(2,5),
(3,0),(3,4),(3,6),
(4,1),(4,3),(4,5),(4,7),
(5,2),(5,4),(5,8),
(6,3),(6,7),
(7,4),(7,6),(7,8),
(8,5),(8,7)]).
swap_pos(L, I, J, R) :-
nth0(I, L, EI),
nth0(J, L, EJ),
set_nth0(L, I, EJ, T),
set_nth0(T, J, EI, R).
set_nth0(L, I, X, R) :- nth0(I, L, _, Rest), nth0(I, R, X, Rest).

% RANDOM SHUFFLE

random_walk(0, S, S).
random_walk(N, S, R) :-
N > 0,
findall(S2, move(S, S2), Neigh),
random_member(Next, Neigh),
N1 is N - 1,
random_walk(N1, Next, R).

% COUNTERS & SMALL HELPERS

reset_moves :- retractall(move_count(_)), asserta(move_count(0)).
inc_moves :- retract(move_count(M)), M1 is M + 1, asserta(move_count(M1)).
tail([_|T], T).
Output:
Welcome to SWI-Prolog (threaded, 64 bits, version 9.2.9)
SWI-Prolog comes with ABSOLUTELY NO WARRANTY. This is free software.
Please run ?- license. for legal details.
For online help and background, visit https://www.swi-prolog.org
For built-in help, use ?- help(Topic). or ?- apropos(Word).
?- [ 'F:\\All details\\8-Puzzle with Best-First Search +.pl' ].
true.
?- start_gui.
true.

output:-
Welcome to SWI-Prolog (threaded, 64 bits, version 9.0.4)
SWI-Prolog comes with ABSOLUTELY NO WARRANTY. This is free software.
Please run ?- license. for legal details.

For online help and background, visit https://www.swi-prolog.org
For built-in help, use ?- help(Topic). or ?- apropos(Word).

?- cd('E:/final year/Artificial Intelligence/code/pratical6.pl').
?- start_gui.
true

